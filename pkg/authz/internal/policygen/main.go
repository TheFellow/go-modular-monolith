package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/fs"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
)

func main() {
	var out string
	flag.StringVar(&out, "out", "policies_gen.go", "output file (relative to pkg/authz)")
	flag.Parse()

	wd, err := os.Getwd()
	must(err)
	repoRoot := filepath.Clean(filepath.Join(wd, "..", ".."))

	files := findCedarFiles(repoRoot)

	buf := &bytes.Buffer{}
	fmt.Fprintln(buf, "// Code generated by policygen; DO NOT EDIT.")
	fmt.Fprintln(buf, "package authz")
	fmt.Fprintln(buf, "")
	fmt.Fprintln(buf, "func policyDocuments() map[string]string {")
	fmt.Fprintln(buf, "\treturn map[string]string{")
	for _, rel := range files {
		abs := filepath.Join(repoRoot, filepath.FromSlash(rel))
		b, err := os.ReadFile(abs)
		must(err)
		fmt.Fprintf(buf, "\t\t%q: %s,\n", rel, strconv.Quote(string(b)))
	}
	fmt.Fprintln(buf, "\t}")
	fmt.Fprintln(buf, "}")

	formatted, err := format.Source(buf.Bytes())
	must(err)

	outPath := filepath.Join(wd, out)
	must(os.WriteFile(outPath, formatted, 0o644))
}

func findCedarFiles(repoRoot string) []string {
	var rels []string

	add := func(abs string) {
		rel, err := filepath.Rel(repoRoot, abs)
		must(err)
		rel = filepath.ToSlash(rel)
		if strings.HasSuffix(rel, ".cedar") {
			rels = append(rels, rel)
		}
	}

	walk := func(root string) {
		_ = filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {
			if err != nil {
				return err
			}
			if d.IsDir() {
				return nil
			}
			if filepath.Ext(path) != ".cedar" {
				return nil
			}
			add(path)
			return nil
		})
	}

	walk(filepath.Join(repoRoot, "pkg", "authz"))
	walk(filepath.Join(repoRoot, "app"))

	sort.Strings(rels)
	return rels
}

func must(err error) {
	if err != nil {
		panic(err)
	}
}
