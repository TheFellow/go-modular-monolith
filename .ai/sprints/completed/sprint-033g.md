# Sprint 033g: Code Generation for Entity ID Types

## Goal

Generate entity ID types from a simple configuration to ensure consistency and make adding new entities trivial.

## Problem

Each entity ID type requires identical boilerplate:

```go
type DrinkID cedar.EntityUID

const (
    TypeDrink   = cedar.EntityType("Mixology::Drink")
    PrefixDrink = "drk"
)

func NewDrinkID() DrinkID { ... }
func ParseDrinkID(id string) (DrinkID, error) { ... }
func (id DrinkID) EntityUID() cedar.EntityUID { ... }
func (id DrinkID) String() string { ... }
func (id DrinkID) IsZero() bool { ... }
```

This is repeated for Drink, Ingredient, Menu, Order, Inventory, Activity, etc. Hand-maintaining these risks:
- Inconsistency between types
- Missing methods
- Copy-paste errors

## Solution

### Configuration File

```go
// app/kernel/entity/entities.go

//go:generate go run ./gen

package entity

// EntityDef defines an entity type for code generation.
type EntityDef struct {
    Name   string // e.g., "Drink"
    Type   string // e.g., "Mixology::Drink"
    Prefix string // e.g., "drk"
}

// Entities defines all entity types in the system.
var Entities = []EntityDef{
    {Name: "Drink", Type: "Mixology::Drink", Prefix: "drk"},
    {Name: "Ingredient", Type: "Mixology::Ingredient", Prefix: "ing"},
    {Name: "Menu", Type: "Mixology::Menu", Prefix: "mnu"},
    {Name: "Order", Type: "Mixology::Order", Prefix: "ord"},
    {Name: "Inventory", Type: "Mixology::Inventory", Prefix: "inv"},
    {Name: "Activity", Type: "Mixology::Activity", Prefix: "act"},
}
```

### Generator

```go
// app/kernel/entity/gen/main.go

package main

import (
    "os"
    "text/template"

    "github.com/TheFellow/go-modular-monolith/app/kernel/entity"
)

var tmpl = template.Must(template.New("entity").Parse(`// Code generated by go generate; DO NOT EDIT.

package entity

import (
    "strings"

    "github.com/TheFellow/go-modular-monolith/pkg/errors"
    cedar "github.com/cedar-policy/cedar-go"
)

{{- range . }}

// {{ .Name }}ID Types and Constants

const (
    Type{{ .Name }}   = cedar.EntityType("{{ .Type }}")
    Prefix{{ .Name }} = "{{ .Prefix }}"
)

// {{ .Name }}ID is a strongly-typed ID for {{ .Name }} entities.
type {{ .Name }}ID cedar.EntityUID

// New{{ .Name }}ID generates a new {{ .Name }}ID with a KSUID.
func New{{ .Name }}ID() {{ .Name }}ID {
    return {{ .Name }}ID(NewID(Type{{ .Name }}, Prefix{{ .Name }}))
}

// Parse{{ .Name }}ID creates a {{ .Name }}ID from a string.
func Parse{{ .Name }}ID(id string) ({{ .Name }}ID, error) {
    if id == "" {
        return {{ .Name }}ID(cedar.NewEntityUID(Type{{ .Name }}, "")), nil
    }
    if !strings.HasPrefix(id, Prefix{{ .Name }}+"-") {
        return {{ .Name }}ID{}, errors.Invalidf("invalid {{ .Name }} ID prefix: %s", id)
    }
    return {{ .Name }}ID(cedar.NewEntityUID(Type{{ .Name }}, cedar.String(id))), nil
}

// EntityUID converts to cedar.EntityUID for Cedar API interop.
func (id {{ .Name }}ID) EntityUID() cedar.EntityUID {
    return cedar.EntityUID(id)
}

// String returns the ID portion as a string.
func (id {{ .Name }}ID) String() string {
    return string(cedar.EntityUID(id).ID)
}

// IsZero returns true if the ID is unset.
func (id {{ .Name }}ID) IsZero() bool {
    return cedar.EntityUID(id).ID == ""
}
{{- end }}
`))

func main() {
    f, err := os.Create("entities_gen.go")
    if err != nil {
        panic(err)
    }
    defer f.Close()

    if err := tmpl.Execute(f, entity.Entities); err != nil {
        panic(err)
    }
}
```

### Generated Output

Running `go generate ./app/kernel/entity` produces:

```go
// app/kernel/entity/entities_gen.go
// Code generated by go generate; DO NOT EDIT.

package entity

import (
    "strings"

    "github.com/TheFellow/go-modular-monolith/pkg/errors"
    cedar "github.com/cedar-policy/cedar-go"
)

// DrinkID Types and Constants

const (
    TypeDrink   = cedar.EntityType("Mixology::Drink")
    PrefixDrink = "drk"
)

type DrinkID cedar.EntityUID

func NewDrinkID() DrinkID {
    return DrinkID(NewID(TypeDrink, PrefixDrink))
}

func ParseDrinkID(id string) (DrinkID, error) {
    if id == "" {
        return DrinkID(cedar.NewEntityUID(TypeDrink, "")), nil
    }
    if !strings.HasPrefix(id, PrefixDrink+"-") {
        return DrinkID{}, errors.Invalidf("invalid Drink ID prefix: %s", id)
    }
    return DrinkID(cedar.NewEntityUID(TypeDrink, cedar.String(id))), nil
}

func (id DrinkID) EntityUID() cedar.EntityUID {
    return cedar.EntityUID(id)
}

func (id DrinkID) String() string {
    return string(cedar.EntityUID(id).ID)
}

func (id DrinkID) IsZero() bool {
    return cedar.EntityUID(id).ID == ""
}

// IngredientID Types and Constants
// ... same pattern ...

// MenuID Types and Constants
// ... same pattern ...

// etc.
```

### File Structure After

```
app/kernel/entity/
├── entities.go      # EntityDef type and Entities slice (source of truth)
├── entities_gen.go  # Generated ID types (DO NOT EDIT)
├── ids.go           # NewID helper function
└── gen/
    └── main.go      # Generator
```

### Adding a New Entity

To add a new entity type:

1. Add to `Entities` slice in `entities.go`:
   ```go
   {Name: "Customer", Type: "Mixology::Customer", Prefix: "cst"},
   ```

2. Run `go generate ./app/kernel/entity`

Done. All types, constructors, parsers, and methods are generated.

## Delete Hand-Written Files

Remove these files (replaced by generated code):
- `app/kernel/entity/drink.go`
- `app/kernel/entity/ingredient.go`
- `app/kernel/entity/menu.go`
- `app/kernel/entity/order.go`
- `app/kernel/entity/inventory.go`
- `app/kernel/entity/audit.go`

## Remove CLI Parsing Helpers

The `main/cli/helpers.go` file has redundant parsing wrappers:

```go
// REMOVE these - they just wrap entity.Parse*
func parseDrinkID(value string) (entity.DrinkID, error) { ... }
func parseIngredientID(value string) (entity.IngredientID, error) { ... }
func parseMenuID(value string) (entity.MenuID, error) { ... }
func parseOrderID(value string) (entity.OrderID, error) { ... }
```

Instead:
1. Use required CLI flags (`Required: true`) to ensure values are provided
2. Call `entity.Parse*` directly in command handlers

**Before:**
```go
func drinkGet(ctx context.Context, cmd *cli.Command) error {
    id, err := parseDrinkID(cmd.String("id"))
    if err != nil {
        return err
    }
    // ...
}
```

**After:**
```go
var drinkGetCmd = &cli.Command{
    Name: "get",
    Flags: []cli.Flag{
        &cli.StringFlag{Name: "id", Required: true, Usage: "Drink ID"},
    },
    Action: func(ctx context.Context, cmd *cli.Command) error {
        id, err := entity.ParseDrinkID(cmd.String("id"))
        if err != nil {
            return err
        }
        // ...
    },
}
```

The `Required: true` flag handles "is it provided?" and `entity.ParseDrinkID` handles "is it valid?"

## Tasks

### Phase 1: Create Generator Infrastructure

- [x] Create `app/kernel/entity/entities.go` with `EntityDef` and `Entities` slice
- [x] Create `app/kernel/entity/gen/main.go` with template and generator
- [x] Add `//go:generate` directive

### Phase 2: Generate and Verify

- [x] Run `go generate ./app/kernel/entity`
- [x] Verify generated `entities_gen.go` compiles
- [x] Verify all ID types have correct methods

### Phase 3: Remove Hand-Written Files

- [x] Delete `app/kernel/entity/drink.go`
- [x] Delete `app/kernel/entity/ingredient.go`
- [x] Delete `app/kernel/entity/menu.go`
- [x] Delete `app/kernel/entity/order.go`
- [x] Delete `app/kernel/entity/inventory.go`
- [x] Delete `app/kernel/entity/audit.go`

### Phase 4: Remove CLI Parsing Helpers

- [x] Remove `parseDrinkID` from `main/cli/helpers.go`
- [x] Remove `parseIngredientID` from `main/cli/helpers.go`
- [x] Remove `parseMenuID` from `main/cli/helpers.go`
- [x] Remove `parseOrderID` from `main/cli/helpers.go`
- [x] Update CLI commands to use `Required: true` flags
- [x] Update CLI commands to call `entity.Parse*` directly

### Phase 5: Verify

- [x] Run `go test ./...` and fix any issues
- [x] Verify `go generate` is idempotent

## Acceptance Criteria

- [x] Single `Entities` slice is the source of truth for all entity types
- [x] `go generate` produces all ID types with consistent implementation
- [x] Generated file has `DO NOT EDIT` header
- [x] Adding a new entity requires only adding to `Entities` and running `go generate`
- [x] No hand-written entity ID files remain
- [x] No redundant `parse*ID` helpers in CLI code
- [x] CLI commands use `Required: true` and `entity.Parse*` directly
- [x] All tests pass

## Result

Adding a new entity type:

```go
// 1. Add one line to entities.go
var Entities = []EntityDef{
    // ... existing ...
    {Name: "Customer", Type: "Mixology::Customer", Prefix: "cst"},  // NEW
}

// 2. Run
// $ go generate ./app/kernel/entity

// 3. Done - CustomerID type now exists with all methods
id := entity.NewCustomerID()
id, err := entity.ParseCustomerID("cst-abc123")
```
